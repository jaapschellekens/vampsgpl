\documentclass{article}\usepackage{makeidx}\makeindex\begin{document}\printindex
\section{util}
% Generated by sldoc (1.14, (C) 1996, 1997) Fri Jan 30 20:23:26 1998


\paragraph{\index{Perror}Perror}
\begin{verbatim}
void Perror(char *Eprogname,int exitval,int prr, char *from,
\end{verbatim}
const char *descr,const char *xtr)


If {\tt prr} $>$ 0 then {\tt perror} is also called.
Prints an error message on stderr and exits with level
exitval if this value is $>$ 0
Normally called with something like:
{\tt Perror(progname,1,RCSid,"A fatal error","divide by zero");}


from: {\tt perror.c}

from file: {\tt doc}


\paragraph{\index{\_\_getval}\_\_getval}
\begin{verbatim}
double __getval(TBL *tab, double xval)
\end{verbatim}
get the y value from xval from table tab. Linear interpolation
is used after the search. This is the old method.


from: {\tt mktable.c}

from file: {\tt doc}


\paragraph{\index{add\_set}add\_set}
\begin{verbatim}
int add_set(xy *XY,char *name,char *fname,int points,int vunit,int tunit);
\end{verbatim}
Adds an XY structure to the data structure and list returns the number
of the set made. If {\tt xy $=$$=$ NULL} the XY structure is allocate with
{\tt points} points. x and Y values are filled with zeros.


from: {\tt dataset.c}

from file: {\tt doc}


\paragraph{\index{del\_set}del\_set}
\begin{verbatim}
int del_set(int nr)
\end{verbatim}
deletes dataset from mem and list and frees the memory allocted to the
actual data. Use {\tt getsetbyname()} to find the sets


The entry in the data struct will remain but the pointer to xy will be
set to {\tt NULL}, indicating the place is free.


from: {\tt dataset.c}

from file: {\tt doc}


\paragraph{\index{dell\_all\_sets}dell\_all\_sets}
\begin{verbatim}
void dell_all_sets()
\end{verbatim}
deletes all datasets from memory


from: {\tt dataset.c}

from file: {\tt doc}


\paragraph{\index{dumpset}dumpset}
\begin{verbatim}
int dumpset (int nr, FILE *stream)
\end{verbatim}
Dumps set {\tt nr} to stream {\tt stream}.


from: {\tt dataset.c}

from file: {\tt doc}


\paragraph{\index{get\_data}get\_data}
\begin{verbatim}
int get_data(char *fname,char *name,int minpt)
\end{verbatim}
Gets data\_point(s) from file fname. The data will be added to the
dataset stuff using {\tt add\_set}. Columns can be given at the end of the
filename separated by comma's. i.e. {\tt afilename,1,3} would tell
{\tt get\_data} the get the data from afilename and use column 1 for X and
column 3 for Y.


If {\tt minpt $>$ 0} then the function will exit if less then minpt are read
from {\tt fname}.


Returns: number of points read


from: {\tt dataset.c}

from file: {\tt doc}


\paragraph{\index{getsetbyname}getsetbyname}
\begin{verbatim}
int getsetbyname(char *s)
\end{verbatim}
returns the number of a named set
searches for a set named name, returns -1 on error
empty positions (xy $=$ NULL ) are skipped


from: {\tt dataset.c}

from file: {\tt doc}


\paragraph{\index{getval}getval}
\begin{verbatim}
double getval(TBL *tab, double x)
\end{verbatim}
Gets the y value corresponding to {\tt x} from {\tt tab}. This version uses
the lasthit hint in the table as a starting point for a
hunt phase. This is followed by bisection and interpolation.
In speed.inp this method is about 18\% faster than the one without the
hunt fase.


from: {\tt mktable.c}

from file: {\tt doc}


\paragraph{\index{memory}memory}
\begin{verbatim}
void *memory(void *ptr, size_t size, char *progname)
\end{verbatim}
Allocates size bytes of memory if ptr $=$$=$ NULL, else
reallocates size bytes from ptr (ANSI realloc()). On
memory error, print diagnostic with progname and exit
with status 1.
Ret:	pointer to allocated memory, deallocate with free(3).


from: {\tt memory.c}

from file: {\tt doc}


\paragraph{\index{mksetstats}mksetstats}
\begin{verbatim}
void mksetstats(int dset)
\end{verbatim}
Fill the simple statistics fields in dataset {\tt dset}. These fields are:
xmin
xmax
ymin
ymax
xsum
ysum


from: {\tt dataset.c}

from file: {\tt doc}


\paragraph{\index{printar}printar}
\begin{verbatim}
void printar(const char *des,double *ar, int pts)
\end{verbatim}
prints the double array {\tt ar} containing {\tt pts} points with
description {\tt des} to the output file


from: {\tt utout.c}

from file: {\tt doc}


\paragraph{\index{printcom}printcom}
\begin{verbatim}
void printcom (const char *des)
\end{verbatim}
prints the comment string {\tt des} to the output file


from: {\tt utout.c}

from file: {\tt doc}


\paragraph{\index{printfl}printfl}
\begin{verbatim}
void printfl(const char *des,double fl)
\end{verbatim}
Prints the double variable {\tt fl} with description {\tt des}
to the output file


from: {\tt utout.c}

from file: {\tt doc}


\paragraph{\index{printint}printint}
void printint(const char *des,int intje)


Prints the integer variable {\tt intje} with description {\tt des}
to the output file


from: {\tt utout.c}

from file: {\tt doc}


\paragraph{\index{printstr}printstr}
\begin{verbatim}
void printstr(const char *des,const char *str)
\end{verbatim}
prints the string {\tt str} with description {\tt des} to the
output file


from: {\tt utout.c}

from file: {\tt doc}


\paragraph{\index{showit}showit}
\begin{verbatim}
void showit (char *from,char *type, char *toshow,
\end{verbatim}
int atverb,int whichverb)


prints stuff to showfile if whichverb $>$$=$ atverb


from: {\tt pro\_mesg.c}

from file: {\tt doc}


\paragraph{\index{utout}utout}
\begin{verbatim}
void utout(int *tstep)
\end{verbatim}
Initialize ini type output per timestep


from: {\tt utout.c}

from file: {\tt doc}
\end{document}
