head	1.26;
access;
symbols;
locks;
comment	@ * @;


1.26
date	99.01.06.12.13.01;	author schj;	state Alpha;
branches;
next	1.25;

1.25
date	99.01.06.12.07.49;	author schj;	state Alpha;
branches;
next	1.24;

1.24
date	97.11.26.13.25.37;	author schj;	state Exp;
branches;
next	1.23;

1.23
date	97.11.25.20.07.04;	author schj;	state Exp;
branches;
next	1.22;

1.22
date	97.09.09.08.39.39;	author schj;	state Exp;
branches;
next	1.21;

1.21
date	97.01.16.15.05.27;	author schj;	state Exp;
branches;
next	1.20;

1.20
date	96.12.30.11.32.50;	author schj;	state Exp;
branches;
next	1.19;

1.19
date	96.11.19.13.47.30;	author schj;	state Exp;
branches;
next	1.18;

1.18
date	96.11.05.15.00.48;	author schj;	state Alpha;
branches;
next	1.17;

1.17
date	96.10.22.17.56.53;	author schj;	state Exp;
branches;
next	1.16;

1.16
date	96.09.19.09.43.39;	author schj;	state Exp;
branches;
next	1.15;

1.15
date	96.04.09.12.08.16;	author schj;	state Exp;
branches;
next	1.14;

1.14
date	96.03.24.11.38.57;	author schj;	state alpha;
branches;
next	1.13;

1.13
date	95.12.17.21.47.37;	author schj;	state Exp;
branches;
next	1.12;

1.12
date	95.12.05.03.04.43;	author schj;	state Exp;
branches;
next	1.11;

1.11
date	95.11.14.20.29.16;	author schj;	state Exp;
branches;
next	1.10;

1.10
date	95.10.19.13.05.57;	author schj;	state Exp;
branches;
next	1.9;

1.9
date	95.09.23.20.46.22;	author schj;	state Exp;
branches;
next	1.8;

1.8
date	95.09.04.11.40.29;	author schj;	state Exp;
branches;
next	1.7;

1.7
date	95.08.28.13.43.40;	author schj;	state Exp;
branches;
next	1.6;

1.6
date	95.08.24.12.57.30;	author schj;	state Exp;
branches;
next	1.5;

1.5
date	95.08.23.07.21.15;	author schj;	state Exp;
branches;
next	1.4;

1.4
date	95.08.16.14.52.33;	author schj;	state Exp;
branches;
next	1.3;

1.3
date	95.08.16.14.48.33;	author schj;	state Exp;
branches;
next	1.2;

1.2
date	95.08.16.14.08.25;	author schj;	state Exp;
branches;
next	1.1;

1.1
date	95.08.16.13.41.01;	author schj;	state Exp;
branches;
next	;


desc
@output per timestep
@


1.26
log
@Version: 0.99g
@
text
@/* $Header: /home/schj/src/vamps_0.99g/src/soil/RCS/soilut.c,v 1.25 1999/01/06 12:07:49 schj Alpha $ */
/*  $RCSfile: soilut.c,v $
 *  $Author: schj $
 *  $Date: 1999/01/06 12:07:49 $
 */

#ifdef DEBUG
static char RCSid[] =
"$Id: soilut.c,v 1.25 1999/01/06 12:07:49 schj Alpha $";
#endif

#include "vamps.h"
#include "soils.h"
#include "swatsoil.h"
#include <math.h>

double volm1;
extern double volsat,volact;

double  noop(int nr, double head)
{
	perror("oops");
	exit(1);
	return MISSVAL;
}
double  (*h2dmc) (int nr, double head) = NULL;  
double  (*t2k) (int nr, double wcon) = NULL;  
double  (*t2h) (int nr, double wcon, double depth) = NULL;  
double  (*h2t) (int nr, double head) = NULL;  
/* in work */
double  (*h2k) (int nr, double head) = noop;  
double  (*h2u) (int nr, double head) = noop;  
double  (*h2dkdp) (int nr, double head) = noop;  

/* this is were the Clapp Horberger (Campbel 1994) functions start */

/*C:h2dmc_0
 *@@ double h2dmc_0 (int nr, double head)
 * 
 * Description: Calculates the differential moisture capacity as a
 * function of pressure head. This is the Campbel 1994
 *
 * Returns: differential moisture content*/
double
h2dmc_0 (int nr, double head)
{
	if (head >= -1.0E-1) {
		return 0.0;
	} else
	return (sp[nr].thetas/(-sp[nr].b*sp[nr].psisat))*
		pow(head/sp[nr].psisat,-(1.0/sp[nr].b)-1.0);
	/* NOTREACHED */
}

/*C:t2k_0
 *@@ double t2k_0(int nr, double wcon)
 * 
 * Description: Calculation of hydraulic conductivity from water
 * content. Clapp Hornberger, or a look up table. This replaces
 * hconode()
 *
 * Returns: k_unsat*/
double
t2k_0 (int nr, double wcon)
{
	double relsat;

	relsat = (wcon - sp[nr].residual_water) / (sp[nr].thetas -
			sp[nr].residual_water);
	relsat = relsat > 1.0 ? 1.0 : relsat; 
	if (relsat < 0.001)
		return 1.0E-10;
	else{
	  return  sp[nr].ksat* pow(wcon/sp[nr].thetas,sp[nr].n*sp[nr].b);
	  /*	  return  sp[nr].ksat* pow(wcon/sp[nr].thetas,sp[nr].b*2+3); */
	}
}


/*C:t2h_0
 *@@double t2h_0 (int nr, double wcon, double depth)
 *
 * Calculates the pressure heads at layer j from the moisture content
 * using Clapp/Hornberger
 * Returns: pressure head
 */

#define MAXSUCKHEAD -1.0E20
double
t2h_0 (int nr, double wcon, double depth)
{
	double ans;

	if ((sp[nr].thetas - wcon) == 0.0 /*< 1.0E-5*/)
		return fabs (depth);
	else{
		if ((wcon - sp[nr].residual_water) < 1.0E-5) {
			return MAXSUCKHEAD * (1-(wcon - sp[nr].residual_water));
		}
		ans =  sp[nr].psisat * pow(wcon/sp[nr].thetas,-1*sp[nr].b);
		return ans < MAXSUCKHEAD ? MAXSUCKHEAD * (1-(wcon -
				sp[nr].residual_water)) : ans;
	}
}

/*C:h2t_0
 *@@ double h2t_0 (int nr, double head)
 * 
 * Calculate the water content at layer j from pressure
 * head @@head@@
 *
 * Returns: theta
 */
double
h2t_0 (int nr, double head)
{
	if (head > sp[nr].psisat)
		return sp[nr].thetas;
	else
		return sp[nr].thetas*pow(head/sp[nr].psisat,-1/sp[nr].b);
	/* NOTREACHED */
}

double
h2k_0( int nr, double head)
{
	if (head >= sp[nr].psisat)
		return sp[nr].ksat;
	else
		return sp[nr].ksat * pow(head/sp[nr].psisat,-sp[nr].n);
}

double
h2u_0 (int nr, double head)
{
	if (head >= sp[nr].psisat)
		return sp[nr].ksat * (-sp[nr].psisat/(sp[nr].n-1) + head - sp[nr].psisat);
	else
		return -(h2k_0(nr,head) * head)/(sp[nr].n-1);
}

double h2dkdp_0(int nr, double head)
{
	if (head >= sp[nr].psisat)
		return 0.0;
	else
		return -(sp[nr].n * sp[nr].ksat)/sp[nr].psisat * pow(head/sp[nr].psisat,-sp[nr].n -1);
}


/* This is where the vam Genuchten functions start */

/*C:h2dmc_1
 *@@ double h2dmc_1 (int nr, double head)
 * 
 * Calculates the differential moisture capacity as a function of pressure head
 *
 * Returns: differential moisture capacity*/
double
h2dmc_1 (int nr, double head)
{
	double term1, term2;
	double alphah;
	double ans;

	if (head >= -1.0E-1){
		return 0.0;
	} else {/* OK we us van Genuchten */
		/* Compute alpha *h */
		alphah = fabs (sp[nr].alpha * head);
		/* Compute|alpha *h|to power n-1 */
		term1 = pow (alphah, sp[nr].n - 1.0);
		term2 = term1 * alphah;
		/* add one and raise to the power m+1 */
		term2 = pow (1.0 + term2, sp[nr].m + 1.0);
		/* dvide theta-s minus theta-r by term2 */
		term2 = (sp[nr].thetas - sp[nr].residual_water) / term2;
		/* Calculate the diff moist coeff */
		ans = fabs (-1.0 * sp[nr].n * sp[nr].m *
				sp[nr].alpha * term2 * term1);
		if (head > -1.0 && ans < 1.0E-7)
			return 0.0;
		else
			return ans;
	} 
}

/*C:t2k_1
 *
 * Prototype: double t2k_1(int nr, double wcon)
 * 
 * Description: Calculation of hydraulic conductivity from water content. Via van Genuchten
 *
 * Returns: k_unsat */
double
t2k_1 (int nr, double wcon)
{
  double relsat, term1, expon1;

  relsat = (wcon - sp[nr].residual_water) / (sp[nr].thetas -
						sp[nr].residual_water);
  relsat = relsat > 1.0 ? 1.0 : relsat; 
  if (relsat < 0.001)
      return 1.0E-10;
  else
     {
	expon1 = sp[nr].l / sp[nr].m - 2.0;
	term1 = pow (1.0 - pow (relsat, 1.0 / sp[nr].m), sp[nr].m);
	return sp[nr].ksat * pow (relsat, expon1) *
	  (1.0 - term1) * (1.0 - term1);
     } 
}


/*C:t2h_1
 *
 * Prototype: double t2h_1 (int nr, double wcon, double depth)
 * 
 * Description: Calculates the pressure heads at layer j from the
 * water content It uses van Genuchten
 *
 * Returns: pressure head */

double
t2h_1 (int nr, double wcon, double depth)
{
  double help;

  if ((sp[nr].thetas - wcon) < 1.0E-6)
	return fabs (depth);
  else
     {			/* Calculate according to van Genuchten */
	if ((wcon - sp[nr].residual_water) < 1.0E-6)
	  {
	     return -1.0E16;
	  }
	else
	  {
	     /* First the inverse of the sorptivity is calculated */
	     help = (sp[nr].thetas - sp[nr].residual_water) /
	       (wcon - sp[nr].residual_water);
	     /* Raise to the power of 1/m */
	     help = pow (help, 1.0 / sp[nr].m);
	     /* Substract one and raise to the power of 1/n */
	     help = pow ((help - 1.0), 1.0 / sp[nr].n);
	     /* Devide by alpha */
	     return -1.0 * fabs (help / sp[nr].alpha);
	  }
     }
}


/*C:h2t_1
 *
 * Prototype: double h2t_1 (int nr, double head)
 * 
 * Description: Calculate the water content at layer j from pressure
 * head, via van Genuchten
 *
 * Returns: water content theta */
double
h2t_1 (int nr, double head)
{
  double help;

   if (head >= -1.0E-6)
     return sp[nr].thetas;
   else
     {
	help = pow (fabs (sp[nr].alpha * head), sp[nr].n);
	help = pow (1.0 + help, sp[nr].m);
	return sp[nr].residual_water + ((sp[nr].thetas -
					      sp[nr].residual_water) / help);
     }
    /* NOTREACHED */
}


double
h2k_1( int nr, double head)
{
	return 0.0;
}

double
h2u_1 (int nr, double head)
{
	return 0.0;
}

double h2dkdp_1(int nr, double head)
{
	return 0.0;
}

/*C:h2dmc_2
 *
 * Prototype: double h2dmc_2 (int nr, double head)
 * 
 * Description: Calculates the differential moisture capacity as a function of pressure head.
 *
 * Returns: differential moisture capacity */
double
h2dmc_2 (int nr, double head)
{
  if (head >= -1.0E-1)
      return 0.0;
  else
     return getval (&sp[nr].tab[H2DMCTAB], head);
}

/*+Name: t2k_2
 *
 *Prototype: double t2k_2(int nr, double wcon)
 * 
 *Description: Calculation of hydraulic conductivity from water
 *content. a look up table. This replaces hconode()
 *
 * Returns: k_unsat+*/
double
t2k_2 (int nr, double wcon)
{
   double relsat;
   
   relsat = (wcon - sp[nr].residual_water) / (sp[nr].thetas -
						  sp[nr].residual_water);
   relsat = relsat > 1.0 ? 1.0 : relsat; 
   if (relsat < 0.001)
     return 1.0E-10;
   else
     return getval (&sp[nr].tab[T2KTAB], wcon);
}

/*+Name: t2h
 *Prototype: double prhnod_2e (int nr, double wcon, double depth)
 *Description: Calculates the pressure heads at layer j from the water content look-up table
 *Returns: pressure head
 +*/

double
t2h_2 (int nr, double wcon, double depth)
{
  if ((sp[nr].thetas - wcon) < 1.0E-6)
	return fabs (depth);
  else
     {
	if ((wcon - sp[nr].residual_water) < 1.0E-6)
	  return -1.0E16;
	else
	  return getval (&sp[nr].tab[T2HTAB], wcon);
     }
}

/*+Name: h2t_2
 *Prototype: double h2t_2 (int nr, double head)
 * 
 *Desciption: Calculate the water content at layer j from pressure head head
 *Returns: water content (theta)
 +*/
double
h2t_2 (int nr, double head)
{
	if (head >= -1.0E-6)
		return sp[nr].thetas;
	else
		return getval (&sp[nr].tab[H2TTAB], head);
}

double
h2k_2 (int nr, double head)
{
	if (head >= 0.0)
		return sp[nr].ksat;
	else
		return getval (&sp[nr].tab[H2KTAB], head);
}

double
h2u_2 (int nr, double head)
{
	return getval (&sp[nr].tab[H2UTAB], head);
}


double 
h2dkdp_2 (int nr, double head)
{
	if (head >= 0.0)
		return 0.0;
	else
		return getval (&sp[nr].tab[H2DKDPTAB], head);
}

#ifdef HAVE_LIBSLANG

/*+Name: h2dmc_3
 *
 * Prototype: double h2dmc_3 (int nr, double head)
 * 
 * Description: Calculates the differential moisture capacity as a function of pressure head.
 *
 * Returns: differential moisture capacity+*/
double
h2dmc_3 (int nr, double head)
{
  double x;
  int xi,tt;

  if(!noslang){
    SLang_push_integer(nr);
    SLang_push_float(head);
    if (!SLang_execute_function("h2dmc")){
      fprintf(stderr,"Error: Function h2t not defined\n");
      exit(1);
    }else
      {
	SLang_pop_float(&x,&xi,&tt);
	return x;
      }
  }
  return MISSVAL;
}

/*+Name: t2k_3
 *
 * Prototype: double t2k_3(int nr, double wcon)
 * 
 * Description: Calculation of hydraulic conductivity from water
 * content. a look up table. This replaces hconode()
 *
 * Returns: k_unsat+*/
double
t2k_3 (int nr, double wcon)
{
  double x;
  int xi,tt;

  if(!noslang){
    SLang_push_integer(nr);
    SLang_push_float(wcon);
    if (!SLang_execute_function("t2k")){
      fprintf(stderr,"Error: Function h2t not defined\n");
      exit(1);
    }else
      {
	SLang_pop_float(&x,&xi,&tt);
	return x;
      }
  }
  return MISSVAL;
}

/*+Name: t2h
 * Prototype: double prhnod_3 (int nr, double wcon, double depth)
 * Description: Calculates the pressure heads at layer j from the water content look-up table
 * Returns: pressure head
 +*/

double
t2h_3 (int nr, double wcon, double depth)
{
  double x;
  int xi,tt;

  if(!noslang){
    SLang_push_integer(nr);
    SLang_push_float(wcon);
    SLang_push_float(depth);
    if (!SLang_execute_function("t2h")){
      fprintf(stderr,"Error: Function t2h not defined\n");
      exit(1);
    }else
      {
	SLang_pop_float(&x,&xi,&tt);
	return x;
      }
  }
  return MISSVAL;
}


/*+Name: h2t_3
 * Prototype: double h2t_3 (int nr, double head)
 * 
 * Desciption: Calculate the water content at layer j from pressure head head
 * Returns: water content (theta)
 +*/
double
h2t_3 (int nr, double head)
{
  double x;
  int xi,tt;

  if(!noslang){
    SLang_push_integer(nr);
    SLang_push_float(head);
    if (!SLang_execute_function("h2t")){
      fprintf(stderr,"Error: Function h2t not defined\n");
      exit(1);
    }else
      {
	SLang_pop_float(&x,&xi,&tt);
	return x;
      }
  }
  return MISSVAL;
}

double
h2k_3 (int nr, double head)
{
	double x;
	int xi,tt;

	if(!noslang){
		SLang_push_integer(nr);
		SLang_push_float(head);
		if (!SLang_execute_function("h2k")){
			fprintf(stderr,"Error: Function h2k not defined\n");
			exit(1);
		}else{
			SLang_pop_float(&x,&xi,&tt);
			return x;
		}
	}
	return MISSVAL;
}

double
h2u_3 (int nr, double head)
{
	double x;
	int xi,tt;
	
	if(!noslang){
		SLang_push_integer(nr);
		SLang_push_float(head);
		if (!SLang_execute_function("h2u")){
			fprintf(stderr,"Error: Function h2u not defined\n");
			exit(1);
		}else{
			SLang_pop_float(&x,&xi,&tt);
			return x;
		}
	}
	return MISSVAL;
}
double
h2dkdp_3 (int nr, double head)
{
	double x;
	int xi,tt;
	
	if(!noslang){
		SLang_push_integer(nr);
		SLang_push_float(head);
		if (!SLang_execute_function("h2dkdp")){
			fprintf(stderr,"Error: Function h2t not defined\n");
			exit(1);
		}else{
			SLang_pop_float(&x,&xi,&tt);
			return x;
		}
	}
	return MISSVAL;
}

#endif



/*C:watcon
 *@@void watcon(void)
 *
 * Determines the actual water content of the profile
 */ 
void
watcon ()
{
	int i;

	volm1 = volact;
	volact = 0.0;

	for (i = 0; i < layers; i++) {
		volact -= (theta[i] * dz[i]);
	}
}

@


1.25
log
@Version: 0.99g
@
text
@d1 1
a1 1
/* $Header: /home/schjpriv/schj/src/vamps_0.99f/src/soil/RCS/soilut.c,v 1.24 1997/11/26 13:25:37 schj Exp $ */
d4 1
a4 1
 *  $Date: 1997/11/26 13:25:37 $
d9 1
a9 1
"$Id: soilut.c,v 1.24 1997/11/26 13:25:37 schj Exp $";
@


1.24
log
@added functions for new nhc (only campbell, table and S-Lang done
@
text
@d1 1
a1 1
/* $Header: /home/schj/src/vamps_0.99f/src/soil/RCS/soilut.c,v 1.23 1997/11/25 20:07:04 schj Exp $ */
d4 1
a4 1
 *  $Date: 1997/11/25 20:07:04 $
d9 1
a9 1
"$Id: soilut.c,v 1.23 1997/11/25 20:07:04 schj Exp $";
d20 6
d31 3
a33 4
double  (*h2k) (int nr, double head) = NULL;  
double  (*h2u) (int nr, double head) = NULL;  
double  (*h2dkdp) (int nr, double head) = NULL;  
double  (*h2dtdp) (int nr, double head) = NULL;  
d279 16
d510 1
a510 1
h2h_3 (int nr, double head)
@


1.23
log
@updated Campbell (Ross & Bristow) functions. psisat used to be
positive, now it is negative as it should be.
@
text
@d1 1
a1 1
/* $Header: /home/schjpriv/schj/src/vamps_0.99e/src/soil/RCS/soilut.c,v 1.22 1997/09/09 08:39:39 schj Exp $ */
d4 1
a4 1
 *  $Date: 1997/09/09 08:39:39 $
d9 1
a9 1
"$Id: soilut.c,v 1.22 1997/09/09 08:39:39 schj Exp $";
d69 1
a69 4
?HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH

Wat is het nou b*3 + 2 of 3/b + 2
	  return  sp[nr].ksat* pow(wcon/sp[nr].thetas,sp[nr].n);
d132 1
a132 1
		return sp[nr].ksat * (-sp[nr].psisat/(sp[nr].n-1) + head - -sp[nr].psisat);
a136 10

double h2dtdp_0(int nr, double head)
{
	if (head >= sp[nr].psisat)
		return 0.0;
	else
		return -sp[nr].thetas/(sp[nr].b * sp[nr].psisat) * 
			pow(head/sp[nr].psisat,(-1/sp[nr].b) - 1);
}

d342 29
a370 4
  if (head >= -1.0E-6)
      return sp[nr].thetas;
  else
     return getval (&sp[nr].tab[H2TTAB], head);
d488 59
d548 1
@


1.22
log
@0.99e version
@
text
@d1 1
a1 1
/* $Header: /home/schjpriv/src/vamps_0.99c/src/soil/RCS/soilut.c,v 1.21 1997/01/16 15:05:27 schj Exp $ */
d4 1
a4 1
 *  $Date: 1997/01/16 15:05:27 $
d9 1
a9 1
"$Id: soilut.c,v 1.21 1997/01/16 15:05:27 schj Exp $";
d24 5
d45 2
a46 2
	return (sp[nr].thetas/(sp[nr].b*sp[nr].psisat))*
		pow((-1.0*head)/sp[nr].psisat,-(1.0/sp[nr].b)-1.0);
d69 5
a73 1
		return  sp[nr].ksat* pow(wcon/sp[nr].thetas,sp[nr].b*2+3);
d98 1
a98 1
		ans =  -1.0*sp[nr].psisat * pow(wcon/sp[nr].thetas,-1*sp[nr].b);
d115 1
a115 1
	if (head > (-1.0 * sp[nr].psisat))
d118 1
a118 1
		return sp[nr].thetas*pow((-1.0*head)/sp[nr].psisat,-1/sp[nr].b);
d122 37
d196 1
a196 1
/*+Name: t2k_1
d202 1
a202 1
 * Returns: k_unsat+*/
d223 1
a223 1
/*+Name: t2h_1
d230 1
a230 1
 * Returns: pressure head+*/
d261 1
a261 1
/*+Name: h2t_1
d268 1
a268 1
 * Returns: water content theta+*/
d286 3
a288 1
/*+Name: h2dmc_2
d294 1
a294 1
 * Returns: differential moisture capacity+*/
@


1.21
log
@layout + stuff
@
text
@d1 1
a1 1
/* $Header: /home/schj/src/vamps_0.99b/src/soil/RCS/soilut.c,v 1.20 1996/12/30 11:32:50 schj Exp $ */
d4 1
a4 1
 *  $Date: 1996/12/30 11:32:50 $
d9 1
a9 1
"$Id: soilut.c,v 1.20 1996/12/30 11:32:50 schj Exp $";
d12 1
a12 1

d27 2
a28 3
/*+Name: h2dmc_0
 *
 * Prototype: double h2dmc_0 (int nr, double head)
d33 1
a33 1
 * Returns: differential moisture content+*/
d37 6
a42 8
   if (head >= -1.0E-1)
     {
	return 0.0;
     }
   else
     return (sp[nr].thetas/(sp[nr].b*sp[nr].psisat))*
     pow((-1.0*head)/sp[nr].psisat,-(1.0/sp[nr].b)-1.0);
   /* NOTREACHED */
d45 2
a46 3
/*+Name: t2k_0
 *
 * Prototype: double t2k_0(int nr, double wcon)
d52 1
a52 1
 * Returns: k_unsat+*/
d56 1
a56 1
  double relsat;
d58 8
a65 8
  relsat = (wcon - sp[nr].residual_water) / (sp[nr].thetas -
						sp[nr].residual_water);
  relsat = relsat > 1.0 ? 1.0 : relsat; 
   if (relsat < 0.001)
     return 1.0E-10;
   else{
     return  sp[nr].ksat* pow(wcon/sp[nr].thetas,sp[nr].b*2+3);
    }
d69 7
a75 6
/*+
Name: t2h_0
Prototype: double t2h_0 (int nr, double wcon, double depth)
Description: Calculates the pressure heads at layer j from the moisture content
Returns: pressure head
 +*/
d81 1
a81 1
  double ans;
d83 10
a92 10
  if ((sp[nr].thetas - wcon) < 1.0E-5)
    return fabs (depth);
  else{
    if ((wcon - sp[nr].residual_water) < 1.0E-5)
      {
	return MAXSUCKHEAD * (1-(wcon - sp[nr].residual_water));
      }
    ans =  -1.0*sp[nr].psisat * pow(wcon/sp[nr].thetas,-1*sp[nr].b);
    return ans < MAXSUCKHEAD ? MAXSUCKHEAD * (1-(wcon - sp[nr].residual_water)) : ans;
  }
d95 2
a96 4
/*+
 * Name: h2t_0
 *
 * Prototype: double h2t_0 (int nr, double head)
d98 2
a99 2
 * Description: Calculate the water content at layer j from pressure
 * head head
d102 1
a102 1
 +*/
d106 5
a110 5
   if (head >= -1.0E-6)
     return sp[nr].thetas;
   else
     return sp[nr].thetas*pow((-1.0*head)/sp[nr].psisat,-1/sp[nr].b);
   /* NOTREACHED */
d115 2
a116 3
/*Name: h2dmc_1
 *
 * Prototype: double h2dmc_1 (int nr, double head)
d118 1
a118 1
 * Description: Calculates the differential moisture capacity as a function of pressure head
d120 1
a120 1
 * Returns: differential moisture capacity+*/
d124 24
a147 27
  double term1, term2;
  double alphah;
  double ans;

   if (head >= -1.0E-1)
     {
	return 0.0;
     }
   else
     {			/* OK we us van Genuchten */
	/* Compute alpha *h */
	alphah = fabs (sp[nr].alpha * head);
	/* Compute|alpha *h|to power n-1 */
	term1 = pow (alphah, sp[nr].n - 1.0);
	term2 = term1 * alphah;
	/* add one and raise to the power m+1 */
	term2 = pow (1.0 + term2, sp[nr].m + 1.0);
	/* dvide theta-s minus theta-r by term2 */
	term2 = (sp[nr].thetas - sp[nr].residual_water) / term2;
	/* Calculate the diff moist coeff */
	ans = fabs (-1.0 * sp[nr].n * sp[nr].m *
		    sp[nr].alpha * term2 * term1);
	if (head > -1.0 && ans < 1.0E-7)
	  return 0.0;
	else
	  return ans;
     } 
d313 1
d428 1
d431 5
a435 6

/*+Name: watcon
 * Prototype: void watcon(void)
 * Description: Determines the actual water content of the profile
 * Returns: nothing
 +*/ 
d439 1
a439 1
  int i;
d441 2
a442 2
  volm1 = volact;
  volact = 0.0;
d444 1
a444 2
  for (i = 0; i < layers; i++)
    {
d446 1
a446 1
    }
@


1.20
log
@Added support fomr method = 5 -> S-Lang theta/h/k/dmc functions
@
text
@d1 1
a1 1
/* $Header: /home/hkl/hydro/promo/schj/nhome/src/vamps_0.99/src/soil/RCS/soilut.c,v 1.19 1996/11/19 13:47:30 schj Exp $ */
d4 1
a4 1
 *  $Date: 1996/11/19 13:47:30 $
d9 1
a9 1
"$Id: soilut.c,v 1.19 1996/11/19 13:47:30 schj Exp $";
d20 4
a23 4
double  (*h2dmcF) (int nr, double head) = NULL;  
double  (*t2kF) (int nr, double wcon) = NULL;  
double  (*t2hF) (int nr, double wcon, double depth) = NULL;  
double  (*h2tF) (int nr, double head) = NULL;  
d348 1
a348 1
  return MISVAL;
d377 1
a377 1
  return MISVAL;
d405 1
a405 1
  return MISVAL;
d433 1
a433 1
  return MISVAL;
@


1.19
log
@Added MAXSUCKHEAD
@
text
@d1 1
a1 1
/* $Header: /home/schj/src/vamps_0.99/src/soil/RCS/soilut.c,v 1.18 1996/11/05 15:00:48 schj Alpha $ */
d4 1
a4 1
 *  $Date: 1996/11/05 15:00:48 $
d9 1
a9 1
"$Id: soilut.c,v 1.18 1996/11/05 15:00:48 schj Alpha $";
d20 4
a23 4
double  (*dmcnodeF) (int j, double head) = NULL;  
double  (*theta2kF) (int j, double wcon) = NULL;  
double  (*prhnodeF) (int j, double wcon) = NULL;  
double  (*thenodeF) (int j, double head) = NULL;  
d26 9
a34 6
/*-
 * double dmcnode_0 (int j, double head)
 * 
 * Calculates the differential moisture capacity as a function
 * of pressure head. This is the Campbel 1994 
 */
d36 1
a36 1
dmcnode_0 (int j,double head)
d43 2
a44 2
     return (soilparm[j].thetas/(soilparm[j].b*soilparm[j].psisat))*
     pow((-1.0*head)/soilparm[j].psisat,-(1.0/soilparm[j].b)-1.0);
d48 9
a56 6
/*-
 * double theta2_0k(int j,double wcon)
 * 
 * Calculation of hydraulic conductivity from water content.
 * Clapp Hornberger, or a look up table. This replaces hconode()
 */
d58 1
a58 1
theta2k_0 (int j,double wcon)
d62 2
a63 2
  relsat = (wcon - soilparm[j].residual_water) / (soilparm[j].thetas -
						soilparm[j].residual_water);
d68 1
a68 1
     return  soilparm[j].ksat* pow(wcon/soilparm[j].thetas,soilparm[j].b*2+3);
d73 6
a78 5
/*-
 *  double prhnode_0 (int j, double wcon)
 * 
 *	Calculates the pressure heads at layer j from the moisture content
 */
d82 1
a82 1
prhnode_0 (int j,double wcon)
d86 2
a87 2
  if ((soilparm[j].thetas - wcon) < 1.0E-5)
    return fabs (depth[j]);
d89 1
a89 1
    if ((wcon - soilparm[j].residual_water) < 1.0E-5)
d91 1
a91 1
	return MAXSUCKHEAD * (1-(wcon - soilparm[j].residual_water));
d93 2
a94 2
    ans =  -1.0*soilparm[j].psisat * pow(wcon/soilparm[j].thetas,-1*soilparm[j].b);
    return ans < MAXSUCKHEAD ? MAXSUCKHEAD * (1-(wcon - soilparm[j].residual_water)) : ans;
d98 4
a101 2
/*-
 * double thenode_0 (int j, double head)
d103 1
a103 1
 * Calculate the water content at layer j from pressure
d105 3
a107 1
 */
d109 1
a109 1
thenode_0 (int j,double head)
d112 1
a112 1
     return soilparm[j].thetas;
d114 1
a114 1
     return soilparm[j].thetas*pow((-1.0*head)/soilparm[j].psisat,-1/soilparm[j].b);
d120 7
a126 6
/*-
 * double dmcnode_1 (int j, double head)
 * 
 * Calculates the differential moisture capacity as a function
 * of pressure head.
 */
d128 1
a128 1
dmcnode_1 (int j,double head)
d141 3
a143 3
	alphah = fabs (soilparm[j].alpha * head);
	/* Compute |alpha *h| to power n-1 */
	term1 = pow (alphah, soilparm[j].n - 1.0);
d146 1
a146 1
	term2 = pow (1.0 + term2, soilparm[j].m + 1.0);
d148 1
a148 1
	term2 = (soilparm[j].thetas - soilparm[j].residual_water) / term2;
d150 2
a151 2
	ans = fabs (-1.0 * soilparm[j].n * soilparm[j].m *
		    soilparm[j].alpha * term2 * term1);
d159 7
a165 6
/*-
 * double theta2k_1(int j,double wcon)
 * 
 * Calculation of hydraulic conductivity from water content.
 * Via van Genuchten,
 */
d167 1
a167 1
theta2k_1 (int j,double wcon)
d171 2
a172 2
  relsat = (wcon - soilparm[j].residual_water) / (soilparm[j].thetas -
						soilparm[j].residual_water);
d178 3
a180 3
	expon1 = soilparm[j].l / soilparm[j].m - 2.0;
	term1 = pow (1.0 - pow (relsat, 1.0 / soilparm[j].m), soilparm[j].m);
	return soilparm[j].ksat * pow (relsat, expon1) *
d186 3
a188 2
/*-
 *  double prhnode_1 (int j, double wcon)
d190 4
a193 4
 *	Calculates the pressure heads at layer j from the
 *	water content
 *	It uses van Genuchten 
 */
d196 1
a196 1
prhnode_1 (int j,double wcon)
d200 2
a201 2
  if ((soilparm[j].thetas - wcon) < 1.0E-6)
	return fabs (depth[j]);
d204 1
a204 1
	if ((wcon - soilparm[j].residual_water) < 1.0E-6)
d211 2
a212 2
	     help = (soilparm[j].thetas - soilparm[j].residual_water) /
	       (wcon - soilparm[j].residual_water);
d214 1
a214 1
	     help = pow (help, 1.0 / soilparm[j].m);
d216 1
a216 1
	     help = pow ((help - 1.0), 1.0 / soilparm[j].n);
d218 1
a218 1
	     return -1.0 * fabs (help / soilparm[j].alpha);
d224 8
a231 6
/*-
 * double thenode_1 (int j, double head)
 * 
 * Calculate the water content at layer j from pressure
 * head 
 */
d233 1
a233 1
thenode_1 (int j,double head)
d238 1
a238 1
     return soilparm[j].thetas;
d241 4
a244 4
	help = pow (fabs (soilparm[j].alpha * head), soilparm[j].n);
	help = pow (1.0 + help, soilparm[j].m);
	return soilparm[j].residual_water + ((soilparm[j].thetas -
					      soilparm[j].residual_water) / help);
d249 7
a255 6
/*-
 * double dmcnode_2 (int j, double head)
 * 
 * Calculates the differential moisture capacity as a function
 * of pressure head.
 */
d257 1
a257 1
dmcnode_2 (int j,double head)
d262 1
a262 1
     return getval (&soilparm[j].tab[DMCNODETAB], head);
d265 3
a267 2
/*-
 * double theta2k_2(int j,double wcon)
d269 4
a272 3
 * Calculation of hydraulic conductivity from water content.
 *  a look up table. This replaces hconode()
 */
d274 1
a274 1
theta2k_2 (int j,double wcon)
d278 2
a279 2
   relsat = (wcon - soilparm[j].residual_water) / (soilparm[j].thetas -
						  soilparm[j].residual_water);
d284 1
a284 1
     return getval (&soilparm[j].tab[THETA2KTAB], wcon);
d287 5
a291 7
/*-
 *  double prhnod_2e (int j, double wcon)
 * 
 *	Calculates the pressure heads at layer j from the
 *	water content
 *      look-up table
 */
d294 1
a294 1
prhnode_2 (int j,double wcon)
d296 2
a297 2
  if ((soilparm[j].thetas - wcon) < 1.0E-6)
	return fabs (depth[j]);
d300 1
a300 1
	if ((wcon - soilparm[j].residual_water) < 1.0E-6)
d303 1
a303 1
	  return getval (&soilparm[j].tab[PRHNODETAB], wcon);
d307 2
a308 2
/*-
 * double thenode_2 (int j, double head)
d310 3
a312 3
 * Calculate the water content at layer j from pressure
 * head head
 */
d314 1
a314 1
thenode_2 (int j,double head)
d317 1
a317 1
      return soilparm[j].thetas;
d319 1
a319 1
     return getval (&soilparm[j].tab[THENODETAB], head);
d323 3
a325 2
/*-
 * void watcon(void)
d327 84
a410 1
 * Determines the actual water content of the profile
d412 32
a443 1
 */ 
@


1.18
log
@Updated to Alpha version
@
text
@d1 1
a1 1
/* $Header: /home/schj/src/vamps_0.99/src/soil/RCS/soilut.c,v 1.17 1996/10/22 17:56:53 schj Exp $ */
d4 1
a4 1
 *  $Date: 1996/10/22 17:56:53 $
d9 1
a9 1
"$Id: soilut.c,v 1.17 1996/10/22 17:56:53 schj Exp $";
d70 1
a70 1
 *	Calculates the pressure heads at layer j from the
d73 1
d77 1
a77 1
double ans;
d79 10
a88 10
   if ((soilparm[j].thetas - wcon) < 1.0E-6)
     return fabs (depth[j]);
   else{
      if ((wcon - soilparm[j].residual_water) < 1.0E-6)
	{
	   return -1.0E16;
	}else
	ans =  -1.0*soilparm[j].psisat * pow(wcon/soilparm[j].thetas,-1*soilparm[j].b);
	return ans < -1.0E16 ? -1.0E16 : ans;
   }
@


1.17
log
@indentation!!
removed log in file
@
text
@d1 1
a1 1
/* $Header: /home/hkl/hydro/promo/schj/nhome/src/vamps_0.99/src/soil/RCS/soilut.c,v 1.16 1996/09/19 09:43:39 schj Exp $ */
d4 1
a4 1
 *  $Date: 1996/09/19 09:43:39 $
d9 1
a9 1
"$Id: soilut.c,v 1.16 1996/09/19 09:43:39 schj Exp $";
@


1.16
log
@Just before adding pointer to k functions etc
@
text
@d1 2
a2 5
/*-
 *  soilut.c - contains functions for calculating head etc in swatsoil.c
 */
/* $Header: /homes/schj/src/vamps_0.98/src/soil/RCS/soilut.c,v 1.15 1996/04/09 12:08:16 schj Exp $ */
/*- $RCSfile: soilut.c,v $
d4 1
a4 26
 *  $Date: 1996/04/09 12:08:16 $
 *  $Log: soilut.c,v $
 *  Revision 1.15  1996/04/09 12:08:16  schj
 *  minor
 *
 *  Revision 1.14  1996/03/24 11:38:57  schj
 *  cosmetic changes
 *
 * Revision 1.13  1995/12/17  21:47:37  schj
 * updated for new getval
 *
 *  Revision 1.12  1995/12/05 03:04:43  schj
 *  added lookup table support
 *
 *  Revision 1.11  1995/11/14 20:29:16  schj
 *  changed include
 *
 * Revision 1.10  1995/10/19  13:05:57  schj
 * seems to work now
 *
 * Revision 1.9  1995/09/23  20:46:22  schj
 * added ifdef DDEBUG
 *
 * Revision 1.8  1995/09/04  11:40:29  schj
 * added log in RCS header
 *
d9 1
a9 1
"$Id: soilut.c,v 1.15 1996/04/09 12:08:16 schj Exp $";
d25 64
d91 19
a109 1
 * double dmcnode (int j, double head, int method)
d115 1
a115 1
dmcnode (int j,double head,int method)
d121 23
a143 33
  if (head >= -1.0E-1)
    {
      return 0.0;
    }
  else
    {
      if (method == 1)
	{			/* OK we us van Genuchten */
	  /* Compute alpha *h */
	  alphah = fabs (soilparm[j].alpha * head);
	  /* Compute |alpha *h| to power n-1 */
	  term1 = pow (alphah, soilparm[j].n - 1.0);
	  term2 = term1 * alphah;
	  /* add one and raise to the power m+1 */
	  term2 = pow (1.0 + term2, soilparm[j].m + 1.0);
	  /* dvide theta-s minus theta-r by term2 */
	  term2 = (soilparm[j].thetas - soilparm[j].residual_water) / term2;
	  /* Calculate the diff moist coeff */
	  ans = fabs (-1.0 * soilparm[j].n * soilparm[j].m *
		      soilparm[j].alpha * term2 * term1);
	  if (head > -1.0 && ans < 1.0E-7)
	    return 0.0;
	  else
	    return ans;
	} else  if (method == 0 ) {
	   return -(soilparm[j].thetas/(soilparm[j].b*soilparm[j].psisat))*
	   	pow(head/soilparm[j].psisat,-(1.0/soilparm[j].b)-1.0);
	}
      else
	{			/* Calculate using look-up table */
	  return getval (&soilparm[j].tab[DMCNODETAB], head);
	}
    }
a145 6
/*

phi = phis * watcon/thetas^ -b
k_unsat = watcon/thetas^(2b+3)

*/
d147 1
a147 1
 * double theta2k(int j,double wcon, int method)
a150 1
 * Clapp Hornberger, or a look up table. This replaces hconode()
d153 1
a153 1
theta2k (int j,double wcon,int method)
a160 1
    {
a161 1
    }
d163 6
a168 16
    {
      if (method == 1)
	{
	  expon1 = soilparm[j].l / soilparm[j].m - 2.0;
	  term1 = pow (1.0 - pow (relsat, 1.0 / soilparm[j].m), soilparm[j].m);
	  return soilparm[j].ksat * pow (relsat, expon1) *
	    (1.0 - term1) * (1.0 - term1);
	} else  if (method == 0 ) {
	   /* Clapp - horberger */
	   return soilparm[j].ksat* pow(wcon/soilparm[j].thetas,soilparm[j].b*2+3);
	}
       else
	 {
	    return getval (&soilparm[j].tab[THETA2KTAB], wcon);
	 }
    }
a171 3



d173 1
a173 1
 *  double prhnode (int j, double wcon, int method)
d177 1
a177 1
 *	It uses van Genuchten or a look-up table
d181 1
a181 1
prhnode (int j,double wcon,int method)
a185 2
    {				/* Saturated */
      /*if (j == 0)*/
a186 3
      /*else
	return h[j - 1] - depth[j];*/
    }
d188 18
a205 33
    {
      if (method == 1)
	{			/* Calculate according to van Genuchten */
	  if ((wcon - soilparm[j].residual_water) < 1.0E-6)
	    {
	      return -1.0E16;
	    }
	  else
	    {
	      /* First the inverse of the sorptivity is calculated */
	      help = (soilparm[j].thetas - soilparm[j].residual_water) /
		(wcon - soilparm[j].residual_water);
	      /* Raise to the power of 1/m */
	      help = pow (help, 1.0 / soilparm[j].m);
	      /* Substract one and raise to the power of 1/n */
	      help = pow ((help - 1.0), 1.0 / soilparm[j].n);
	      /* Devide by alpha */
	      return -1.0 * fabs (help / soilparm[j].alpha);
	    }
	}
      else if (method == 0){
	 /* Clapp - Horberger */
	 return soilparm[j].psisat * pow(wcon/soilparm[j].thetas,-1*soilparm[j].b);
      }else
	{			/* Calculate using look-up table */
	  if ((wcon - soilparm[j].residual_water) < 1.0E-6)
	    {
	      return -1.0E16;
	    }
	  else
	    return getval (&soilparm[j].tab[PRHNODETAB], wcon);
	}
    }
d210 1
a210 1
 * double thenode (int j, double head, int method)
d213 1
a213 1
 * head head
d216 1
a216 1
thenode (int j,double head,int method)
d220 78
a298 1
    {
a299 1
    }
d301 1
a301 17
    {
      if (method==1)
	{			/* Use van genuchten */
	  help = pow (fabs (soilparm[j].alpha * head), soilparm[j].n);
	  help = pow (1.0 + help, soilparm[j].m);
	  return soilparm[j].residual_water + ((soilparm[j].thetas -
				      soilparm[j].residual_water) / help);
	}
      else if (method == 0){
	 /* Clapp - Horberger */
	 return soilparm[j].thetas*pow(head/soilparm[j].psisat,-1/soilparm[j].b);
      }else
	 {			/* Calculate using look-up table */
	  return getval (&soilparm[j].tab[THENODETAB], head);
	 }
    }
    /* NOTREACHED */
d304 1
d321 1
a321 1
		volact = volact - (theta[i] * dz[i]);
@


1.15
log
@minor
@
text
@d2 1
a2 1
 * soilut.c - contains functions for calculating head etc in swatsoil.c
d4 1
a4 1
/* $Header: /home/hkl/hydro/promo/schj/nhome/src/vamps_0.98/src/soil/RCS/soilut.c,v 1.14 1996/03/24 11:38:57 schj alpha $ */
d7 1
a7 1
 *  $Date: 1996/03/24 11:38:57 $
d9 3
d37 1
a37 1
"$Id: soilut.c,v 1.14 1996/03/24 11:38:57 schj alpha $";
d48 4
d56 1
d91 3
d102 6
d110 1
d135 8
a142 5
	}
      else
	{
	  return getval (&soilparm[j].tab[THETA2KTAB], wcon);
	}
d152 1
d191 4
a194 1
      else
d209 1
d231 5
a235 2
      else
	{			/* Calculate using look-up table */
d237 1
a237 1
	}
d239 1
a239 1
    /* Not reached */
d242 6
@


1.14
log
@cosmetic changes
@
text
@d4 1
a4 1
/* $Header: /home/hkl/hydro/promo/schj/nhome/src/vamps_0.97/src/soil/RCS/soilut.c,v 1.13 1995/12/17 21:47:37 schj Exp $ */
d7 1
a7 1
 *  $Date: 1995/12/17 21:47:37 $
d9 3
d34 1
a34 1
"$Id: soilut.c,v 1.13 1995/12/17 21:47:37 schj Exp $";
d143 1
a143 1
      if (j == 0)
d145 2
a146 2
      else
	return h[j - 1] - depth[j];
d192 1
a192 1
  if (head >= -1.0E-2)
a226 6
double
mkkgeom(int layer)
{
	/*return sqrt(k[layer]*k[layer-1]);*/
	return 0.5 * (k[layer] + k[layer-1]);
}
@


1.13
log
@updated for new getval
@
text
@d4 1
a4 1
/* $Header: /home/schj/src/vamps_0.95/src/soil/RCS/soilut.c,v 1.12 1995/12/05 03:04:43 schj Exp $ */
d7 1
a7 1
 *  $Date: 1995/12/05 03:04:43 $
d9 3
d31 1
a31 1
"$Id: soilut.c,v 1.12 1995/12/05 03:04:43 schj Exp $";
d39 2
a40 1
double volact, volm1, volsat;
d50 1
a50 4
dmcnode (j, head, method)
     int j;
     double head;
     int method;
d95 1
a95 4
theta2k (j, wcon, method)
     int j;
     double wcon;
     int method;
d134 1
a134 4
prhnode (j, wcon, method)
     int j;
     double wcon;
     int method;
d185 1
a185 4
thenode (j, head, method)
     int j;
     double head;
     int method;
d220 1
a220 1
      volact = volact - (theta[i] * dz[i]);
d222 7
@


1.12
log
@added lookup table support
@
text
@d4 1
a4 1
/* $Header: /home/schj/src/vamps_0.91/soil/RCS/soilut.c,v 1.11 1995/11/14 20:29:16 schj Exp $ */
d7 1
a7 1
 *  $Date: 1995/11/14 20:29:16 $
d9 3
d28 1
a28 1
"$Id: soilut.c,v 1.11 1995/11/14 20:29:16 schj Exp $";
d82 1
a82 1
	  return getval (&soilparm[j].tab[DMCNODETAB], head,lin);
d103 1
d119 1
a119 1
	  return getval (&soilparm[j].tab[THETA2KTAB], wcon,lin);
d156 1
a156 1
	      return -1.0E12;
d175 1
a175 1
	      return -1.0E12;
d178 1
a178 1
	    return getval (&soilparm[j].tab[PRHNODETAB], wcon,lin);
d212 1
a212 1
	  return getval (&soilparm[j].tab[THENODETAB], head,lin);
@


1.11
log
@changed include
@
text
@d4 1
a4 1
/* $Header: /homes/schj/src/vamps_0.91/RCS/soilut.c,v 1.10 1995/10/19 13:05:57 schj Exp $ */
d7 1
a7 1
 *  $Date: 1995/10/19 13:05:57 $
d9 3
d25 1
a25 1
"$Id: soilut.c,v 1.10 1995/10/19 13:05:57 schj Exp $";
d33 1
a33 1
double	volact,volm1,volsat;
d44 3
a46 3
int     j;
double  head;
int     method;
d48 1
a48 1
  double  term1, term2;
a49 1
  int     lay;
d52 8
a59 11
  /* Soil layer of node */
  lay = j;

  if (method)
    {				/* OK we us van Genuchten */
      if (head >= -1.0E-1)
	{
	  return 0.0;
	}
      else
	{
d61 1
a61 1
	  alphah = fabs(soilparm[lay].alpha * head);
d63 2
a64 2
	  term1 = pow (alphah, soilparm[lay].n - 1.0);
	  term2= term1 * alphah;
d66 1
a66 1
	  term2 = pow (1.0 + term2, soilparm[lay].m + 1.0);
d68 1
a68 1
	  term2 = (soilparm[lay].thetas - soilparm[lay].residual_water) / term2;
d70 2
a71 2
	  ans= fabs (-1.0 * soilparm[lay].n * soilparm[lay].m *
		       soilparm[lay].alpha * term2 * term1);
d73 1
a73 1
	  	return 0.0;
d75 5
a79 1
	  	return ans;
a81 6
  else
    {				/* Calculate using look-up table */
      (void) fprintf (stderr, "Option not yet implemented (Calculation via tables");
      exit (1);
    }

d91 4
a94 4
theta2k (j, wcon,method)
int     j;
double  wcon;
int     method;
d96 1
a96 1
double	relsat,term1,expon1;
d98 3
a100 1
  if (method)
d102 10
a111 6
      relsat = (wcon - soilparm[j].residual_water) / (soilparm[j].thetas -
						 soilparm[j].residual_water);
      if (relsat > 0.99)
	{			/* linear interpolation of k */
	  return soilparm[j].kse99 + (relsat - 0.99) / 0.01 *
	    (soilparm[j].ksat - soilparm[j].kse99);
d115 1
a115 11
	  if (relsat < 0.001)
	    {
	      return 1.0E-10;
	     }
	  else
	    {
	      expon1 = soilparm[j].l / soilparm[j].m - 2.0;
	      term1 = pow(1.0 - pow(relsat, 1.0 / soilparm[j].m),soilparm[j].m);
		return soilparm[j].ksat * pow (relsat, expon1) *
		  (1.0 - term1) * (1.0 - term1);
	    }
a117 5
  else
    {
      (void) fprintf (stderr, "Option not yet implemented (Calculation via tables");
      exit (1);
    }
d133 3
a135 3
int     j;
double  wcon;
int	method;
d137 1
a137 3
  double  help;
  int     lay;

d139 1
a139 3
  lay = j;

  if ((soilparm[lay].thetas - wcon) < 1.0E-6)
d142 1
a142 1
	return fabs (depth[lay]);
d144 1
a144 1
	return h[lay - 1] - depth[lay];
d148 1
a148 1
      if (method)
d150 1
a150 1
	  if ((wcon - soilparm[lay].residual_water) < 1.0E-6)
d157 2
a158 2
	      help = (soilparm[lay].thetas - soilparm[lay].residual_water) /
		(wcon - soilparm[lay].residual_water);
d160 1
a160 1
	      help = pow (help, 1.0 / soilparm[lay].m);
d162 1
a162 1
	      help = pow ((help - 1.0), 1.0 / soilparm[lay].n);
d164 1
a164 1
	      return -1.0 * fabs (help / soilparm[lay].alpha);
d169 6
a174 2
	  (void) fprintf (stderr, "Option not yet implemented (Calculation via tables");
	  exit (1);
d187 3
a189 3
int     j;
double  head;
int	method;
d191 1
a191 5
  double  help;
  int     lay;

  /* Soil layer of node */
  lay = j;
d195 1
a195 1
      return soilparm[lay].thetas;
d199 1
a199 1
      if (method)
d201 4
a204 4
	  help = pow (fabs (soilparm[lay].alpha * head), soilparm[lay].n);
	  help = pow (1.0 + help, soilparm[lay].m);
	  return soilparm[lay].residual_water + ((soilparm[lay].thetas -
				       soilparm[lay].residual_water) / help);
d208 1
a208 2
	  (void) fprintf (stderr, "Option not yet implemented (Calculation via tables");
	  exit (1);
d211 1
a211 2

  return 0.0;
d217 1
a217 1
int	i;
d219 2
a220 2
volm1 = volact;
volact = 0.0;
d222 4
a225 2
for (i=0;i<layers;i++){
	volact = volact - (theta[i] * dz[i]);
a226 2
}

@


1.10
log
@seems to work now
@
text
@d4 1
a4 1
/* $Header: /home/hkl/hydro/promo/schj/nhome/src/prosper/vamps_0.9/soil/RCS/soilut.c,v 1.9 1995/09/23 20:46:22 schj Exp $ */
d7 1
a7 1
 *  $Date: 1995/09/23 20:46:22 $
d9 3
d22 1
a22 1
"$Id: soilut.c,v 1.9 1995/09/23 20:46:22 schj Exp $";
d26 2
a27 2
#include "../include/soils.h"
#include "../include/swatsoil.h"
@


1.9
log
@added ifdef DDEBUG
@
text
@d4 1
a4 1
/* $Header: /home/hkl/hydro/promo/schj/nhome/src/prosper/vamps_0.9/soil/RCS/soilut.c,v 1.8 1995/09/04 11:40:29 schj Exp $ */
d7 1
a7 1
 *  $Date: 1995/09/04 11:40:29 $
d9 3
d19 1
a19 1
"$Id: soilut.c,v 1.8 1995/09/04 11:40:29 schj Exp $";
d43 1
d58 2
d61 2
a62 3
	  term1 = pow (fabs (soilparm[lay].alpha * head), soilparm[lay].n - 1.0);
	  /* Raise to the power n */
	  term2 = pow (term1, soilparm[lay].n);
a116 5
	      /*if (swmobl == 1)
		return fmobil[j] * (soilparm[j].ksat *
				    pow (relsat, expon1) *
				    (1.0 - term1) * (1.0 - term1));
	      else*/
@


1.8
log
@added log in RCS header
@
text
@d1 4
a4 1
/* $Header: /home/hkl/hydro/promo/schj/nhome/src/prosper/vamps_0.9/soil/RCS/soilut.c,v 1.7 1995/08/28 13:43:40 schj Exp $ */
d7 5
a11 2
 *  $Date: 1995/08/28 13:43:40 $
 *  $Log$
d14 1
d16 2
a17 4
"$Id: soilut.c,v 1.7 1995/08/28 13:43:40 schj Exp $";

/* soilut.c - contains functions for calculating head etc in swatsoil.c
 */
d29 1
a29 1
 * double dmcnode (int j, double head)
d34 1
a34 1
dmcnode (j, head)
d37 1
d46 1
a46 1
  if (kvspsim[lay])
d80 1
a80 1
 * double theta2k(int j,double wcon)
d86 1
a86 1
theta2k (j, wcon)
d89 1
d93 1
a93 1
  if (kvspsim[j])
d134 1
a134 1
 *  double prhnode (j,wcon)
d141 1
a141 1
prhnode (j, wcon)
d144 1
d161 1
a161 1
      if (kvspsim[lay])
d190 1
a190 1
 * double thenode (int j, double head)
d195 1
a195 1
thenode (j, head)
d198 1
d212 1
a212 1
      if (kvspsim[lay])
@


1.7
log
@fixed small typo's
@
text
@d1 1
a1 1
/* $Header: /home/hkl/hydro/promo/schj/nhome/src/prosper/vamps_0.8/soil/RCS/soilut.c,v 1.6 1995/08/24 12:57:30 schj Exp $ */
d4 2
a5 1
 *  $Date: 1995/08/24 12:57:30 $
d9 1
a9 1
"$Id: soilut.c,v 1.6 1995/08/24 12:57:30 schj Exp $";
@


1.6
log
@added RCSid
@
text
@d1 1
a1 1
/* $Header: /home/hkl/hydro/promo/schj/nhome/src/prosper/vamps_0.8/soil/RCS/soilut.c,v 1.5 1995/08/23 07:21:15 schj Exp $ */
d4 1
a4 1
 *  $Date: 1995/08/23 07:21:15 $
d7 2
a8 2
static const char RCSid[] =
"$Id: vsel.c,v 1.5 1995/08/24 12:47:38 schj Exp $";
@


1.5
log
@updated theta2k, contained an error
@
text
@d1 1
a1 1
/* $Header: /home/hkl/hydro/promo/schj/nhome/src/prosper/vamps_0.8/soil/RCS/soilut.c,v 1.4 1995/08/16 14:52:33 schj Exp $ */
d4 1
a4 2
 *  $Date: 1995/08/16 14:52:33 $
 *
d6 5
a10 3
/* soilut.c
 *	contains functions for calculating head etc in swatsoil.c
 *
@


1.4
log
@updated thenode
@
text
@d1 1
a1 1
/* $Header: /home/hkl/hydro/promo/schj/nhome/src/prosper/vamps_0.8/soil/RCS/soilut.c,v 1.3 1995/08/16 14:48:33 schj Exp $ */
d4 1
a4 1
 *  $Date: 1995/08/16 14:48:33 $
d72 1
a72 1
 * double thata2k(int j,double wcon)
a85 3
      if (wcon >= soilparm[j].thetas)
      	return soilparm[j].ksat;

d98 1
a98 1
	    }
d102 1
a102 1
	      term1 = pow(pow (1.0 - relsat, 1.0 / soilparm[j].m),soilparm[j].m);
@


1.3
log
@updated dmcnode to net swap source
@
text
@d1 1
a1 1
/* $Header: /home/hkl/hydro/promo/schj/nhome/src/prosper/vamps_0.8/soil/RCS/soilut.c,v 1.2 1995/08/16 14:08:25 schj Exp $ */
d4 1
a4 1
 *  $Date: 1995/08/16 14:08:25 $
d198 1
a198 1
  if (head >= 0.0)
@


1.2
log
@*** empty log message ***
@
text
@d1 2
a2 2
/* $Header: /home/hkl/hydro/promo/schj/nhome/src/prosper/vamps_0.8/soil/RCS/headcalc.c,v 1.3 1995/08/16 14:05:43 schj Exp $ */
/*- $RCSfile: headcalc.c,v $
d4 1
a4 1
 *  $Date: 1995/08/16 14:05:43 $
d40 1
a40 1
      if (head >= 0.0)
d42 1
a42 1
	  return 1.0E-7;
d57 2
a58 2
	  if (head > -1.0 && ans < 1.0E-1)
	  	return 1.0E-7;
@


1.1
log
@Initial revision
@
text
@d1 6
@
