#!/usr/local/bin/vamps -I 
%
% sldoc - C/S-Lang documentation facility
%

% global stuff
variable doc_key = "%I:";	% use C for C doc
variable doc_c_key = "/*I:";	% use "/*C:" for C doc
variable doc_idx_fn = "sldoc.idx";  % index filename
variable doc_idx = getdefname(doc_idx_fn); % full path to index 
variable doc_ver = "1.14";	% current version
variable doc_fmt;		% formatter function, set in main
variable doc_msg = "%s Generated by %s (%s, (C) 1996, 1997) %s\n";

% set by sldoc_pre, used by the formatters
variable docline = 0;		% total lines output
variable doc_line;		% output line of current entry
variable doc_lm;		% mode of last line, 0=text, 1=verbatim
variable doc_cm;		% current line mode, 0=text, 1=verbatim
variable doc_pp;		% insert parspace if non-zero
variable doc_fname;		% filename from which documentation is extracted

% usage message
define sldoc_usage()
{
	fprintf(stderr, "%s - Generate or extract documentation from S-Lang or C files.\n", arg0, 1);
	fprintf(stderr, "Usage: %s [-kkey -Kckey][-c|-L] file ...\n", arg0, 1);
	fprintf(stderr, "       %s [-kkey -Kckey] -i file ...\n", arg0, 1);
	fprintf(stderr, "       %s [-kkey -Kckey][-l|-t] name ...\n", arg0, 1);
	fprintf(stderr, "\n\t1) -c/-L extract documentation from C/LaTeX files\n", 0);
	fprintf(stderr, "\t2) -i generate an index\n", 0);
	fprintf(stderr, "\t3) -l/-t generate documentation in LaTeX of troff format\n", 0);
	fprintf(stderr, "\tall) -kkey -Kkey set S-Lang/C key to key\n", 0);
	%exit;
}

% open file and return handle, print diagnostic and exit on error
define sldoc_fopenr(file)
{
	variable fd = fopen(getdefname(file), "r");
	if(fd >= 0)
		return(fd);
	fprintf(stderr, "%s: Cannot open file \"%s\"\n", arg0, file, 2);
	%exit;
}

% find next key in index file with handle fd
define sldoc_getkey(fd, key)
{
variable idx, n, s;

while(fgets(fd) > 0) {
	s = strtrim();
	if((s[0] == '%') or (strlen(s) == 0))
		continue;
	idx = strv(s, " ");
	n = asize(idx);
	if((strcmp(idx[0], key) == 0) or (strcmp(idx[1], key) == 0))
		return(idx, n);
}
return(0, -1);
}

% open file and search key, return fd, -1 if key not found
define sldoc_entry(file, key)
{
variable fd, s, len;

fd = sldoc_fopenr(file);
s = strcat(doc_key, key);
len = strlen(s);
while(fgets(fd) > 0) {
	if(strncmp(s, len) == 0){
		doc_fname = file;
		return(fd);
	}
}
fclose(fd);
return(-1);
}

% hacked str_replace_all to prevent paranoia
define str_replace_all(orig, match, replacement)
{
variable no_way = "|||||";

while(str_replace(orig, match, no_way))
	orig = ();
while(str_replace(orig, no_way, replacement))
	orig = ();
return(orig);
}

% raw ascii output on stdout
define sldoc_ascii(s)
{
% first output line
if(docline == 1)
	printf(doc_msg, "%", arg0, doc_ver,time, 4);

% simply insert blank line on mode switch or parspace
if((doc_cm != doc_lm) or doc_pp)
	echo("");

% first line in entry, insert spaces
if(doc_line == 1)
	s = sprintf("\n\n%s\n", s, 1);

% strip all @'s if not in verbatim mode
	else if(doc_cm == 0)
		s = str_replace_all(s, "@", "");

% output line
	() = fputs(s, stdout);

	return;
}

% [gnt]roff output on stdout
define sldoc_troff(s)
{
% first output line
	if(docline == 1) {
		printf(doc_msg, ".\\\"", arg0, doc_ver,time, 4);
		printf(".if t .ds *p .sp 0.3v\n", 0);
		printf(".if n .ds *p .sp\n\n", 0);
		printf(".fp 2 CW\n", 0);
	}

% reset normal mode on switch or at last line if left in verbatim
	if(((doc_cm == 0) and (doc_lm == 1))
		or ((strlen(s) == 0) and (doc_cm == 1)))
		echo("\\*(*p\n.ft R\n.fi");

% switch to verbatim
	else if((doc_cm == 1) and (doc_lm == 0))
		echo(".nf\n.ft 2\n\\*(*p");

% insert parspace if not mode switch
	else if(doc_pp)
		echo("\\*(*p");

% substitute escapes in both modes, must be done first
	s = str_replace_all(s, "\\", "\\e");

% first line in entry, (header)
	if(doc_line == 1)
		s = sprintf("\\\\*(*p\n\\\\*(*p\n\\\\fB%s\\\\fR\n", s, 1);

% post-process output line if not in verbatim mode
	else if(doc_cm == 0) {
		while(str_replace(s, "@", "\\f2")) {
			if(str_replace("@", "\\fR") == 0)
				break;		% odd number of @'s
			s = ();
		}
	}

% output line
	() = fputs(s, stdout);

	return;
}

% LaTeX output on stdout
% Seems to work ok. Some code to deal with equations should
% probably be added sometime in the future
define sldoc_latex(s)
{
% first output line
	if(docline == 1) {
		printf(doc_msg, "%", arg0, doc_ver,time, 4);
	}

% reset normal mode on switch or at last line if left in verbatim
	if(((doc_cm == 0) and (doc_lm == 1))
		or ((strlen(s) == 0) and (doc_cm == 1)))
		echo("\\end{verbatim}");

% switch to verbatim
	else if((doc_cm == 1) and (doc_lm == 0)){
		echo("\\begin{verbatim}");
	}

% insert parspace if not mode switch 
% one newline in verbatim mode, two in normal!
	else if((doc_pp) and (doc_cm != 1)){
		echo("\n");
	}else if(doc_pp)
		echo("");

% substitute escapes in normal mode, must be done first
	if (doc_cm == 0){
		s = str_replace_all(s,"\\","\\verb1\\1");
		s = str_replace_all(s,"}","\\}");
		s = str_replace_all(s,"{","\\{");
		s = str_replace_all(s,"_","\\_");
		s = str_replace_all(s,"$","\\$");
% Put some stuff in math mode
		s = str_replace_all(s,">","$>$");
		s = str_replace_all(s,"<","$<$");
		s = str_replace_all(s,"=","$=$");
		s = str_replace_all(s,"/","$/$");
% other special chars
		s = str_replace_all(s,"%","\\%");
		s = str_replace_all(s,"&","\\&");
		s = str_replace_all(s,"^","\\verb1^1");
		s = str_replace_all(s,"~","\\verb1~1");
		s = str_replace_all(s,"#","\\#");
	}else
% Replace tabs with spaces (4) in verbatim mode
		s = str_replace_all(s,"\t","    ");

% first line in entry, (header)
	if(doc_line == 1){
		printf("\n\n\\\\paragraph{\\\\index{%s}%s}\n",s,s,2);
% post-process output line if not in verbatim mode
	}else if(doc_cm == 0) {
		while(str_replace(s, "@", "{\\tt ")) {
			if(str_replace("@", "}") == 0)
				break;		% odd number of @'s
			s = ();
		}
	}

% output line except for key (line 1)
	if (doc_line != 1)
		() = fputs(s, stdout);

	return;
}

% example code for a generic formatter, this one has
% been tested for every lunacase we could think of
% define sldoc_generic(s)
% {
% first output line
%	if(docline == 1)
%		printf(doc_msg, "%", arg0, doc_ver,time, 4);
%
% reset normal mode on switch or at last line if left in verbatim
% 	if(((doc_cm == 0) and (doc_lm == 1))
% 		or ((strlen(s) == 0) and (doc_cm == 1)))
% 		echo("(end verbatim)");
%
% switch to verbatim
%	else if((doc_cm == 1) and (doc_lm == 0))
%		echo("(start verbatim)");
%
% insert parspace if not mode switch
%	else if(doc_pp)
%		echo("(par)");
%
% first line in entry, header key comes without newline
%	if(doc_line == 1)
%		s = sprintf("(next\n key)\n%s\n", s, 1);
%
% post-process output line if not in verbatim mode
%	else if(doc_cm == 0) {
%	%	...
%	% this one simply strips all @'s
%		s = str_replace_all(s, "@", "");
%	}
%
% output line
%	() = fputs(s, stdout);
%
%	return;
% }

% prepocess entry, call formatter line by line
define sldoc_pre(key)
{
	variable ifd, sfd, idx, n, s;
	

% open index file, exits if not found
	ifd = sldoc_fopenr(doc_idx);

% get all key matches from the index file
	while((idx, n) = sldoc_getkey(ifd, key), n != -1) {

	% get entry point for key in .sl file
		if(sfd = sldoc_entry(idx[1], idx[0]), sfd == -1)
			continue;	% entry not found (idx corrupted)

	% set up and print header
		docline++;		% increase total line count
		doc_cm = 0;		% normal mode
		doc_lm = 0;		% normal mode
		doc_line = 1;		% set entry line
		doc_pp = 0;		% let formatter handle this
		doc_fmt(idx[0]);	% no newline!!

	% do all lines starting with '%'
		while(fgets(sfd) > 0) {
			s = ();
			if(s[0] != '%')
				break;		% last entry line
			if(strncmp(s, doc_key, 3) == 0)
				continue;	% other key, same entry

		% verbatim text, strip ' ' after '@'
			if(s[1] == '@') {
				for(n = 2; s[n] == ' '; n++) ;
				doc_cm = 1;
			}

		% normal text, strip ' ' and '\t' after '%'
			else {
				for(n = 1; (s[n] == ' ')
						or (s[n] == '\t'); n++) ;
				doc_cm = 0;
			}

		% squeeze multiple blank lines
			if(s[n] == '\n')
				doc_pp++;

		% set statii and format
			else {
				docline++;
				doc_line++;
				doc_fmt(substr(s, n + 1, -1));
				doc_lm = doc_cm;
				doc_pp = 0;
			}
		}
	% finish, formatter must reset if left in verbatim mode
		doc_pp = 0;
		doc_fmt(sprintf("\nfrom file: @%s@\n",doc_fname,1));
		doc_fmt("");
		() = fflush(stdout);
		() = fclose(sfd);
	}
	() = fclose(ifd);

	return(0);
}

% build index for file on stdout
define sldoc_idx(file)
{
	variable fd, s, key;

	fd = sldoc_fopenr(file);
	while(fgets(fd) > 0) {
		s = ();
		if((strncmp(s, doc_key, 3) == 0) and (strlen(s) > 4)) {
			if(docline++, docline == 1)
				printf(doc_msg, "%", arg0, doc_ver,time, 4);
			key = strtrim(substr(s, 4, strlen(s) - 4));
			printf("%s %s\n", key, file, 2);
		}
	}
	() = fclose(fd);
	return(0);
}


define sldoc_lconv(file)
{
	variable fd, s, l_stat = 0,ll_stat = 0;

	fd = sldoc_fopenr(file);
	while(fgets(fd) > 0) {
		s = strtrim();
		ll_stat = 0;
		if((strncmp(s, doc_key, 3) == 0) and (strlen(s) > 4)) {
			l_stat = 1;
			ll_stat = 1;
		}

		if(strncmp(s, "%E:", 3) == 0) 
			l_stat = 0;
		if (l_stat == 1){
			s = str_replace_all(s,"\\vamps\\","@Vamps@");
			if (ll_stat == 1)
				printf("%s\n",s,1);
			else
				printf("%% %s\n",s,1);
		}
	}
	() = fclose(fd);
	return(0);
}

% Get comments from C files and convert to S-Lang comments
% for processing with the sldoc system. Supports comment
% blocks with and without leading * and whitespace, e.g.,
%	/*I:key
%   	 * ...
%	 */
% and:
%	/*I:key
%	  ...
%	  ... */ 
% The first is recommended
% A last line containing the name of the C file is added
define sldoc_cconv(file)
{
	variable fd, s, ll_stat = 0, l_stat = 0;

	fd = sldoc_fopenr(file);
	while(fgets(fd) > 0) {
		s = strtrim();
		ll_stat = l_stat;
	% '*' or '/' is the first char if in a comment
		if(l_stat == 1) {
		% is this the last line?
			if(is_substr(s,"*/")) {
				if(strlen(s) > 3) { 

				% not closed on separate line, strip tail
					() = str_replace(s, "*/", "");
					s = ();
					if(s[0] == '*')
						s = strsub(s, 1, '%');
				} else {

		% closed on separate line, replace with '%'
					() = str_replace(s, "*/", "%");
					s = ();
				}

		% set close comment flag
				l_stat = 0;
			}
			else if(s[0] == '*')

		% replace leading '*' with '%'
				s = strsub(s, 1, '%');
			if(s[0] == '%')
				printf("%s\n", s, 1);
			else
		% add '%' if the comment line does not have a leading '*'
				printf("%% %s\n", s, 1);
		}

		% check for start of comment -- key-line 
		if((strncmp(s, doc_c_key, 4) == 0) and (strlen(s) > 4)) {
			l_stat = 1;	
			() = str_replace(s, doc_c_key, doc_key);
			s = ();
			if(docline++, docline == 1)
				printf(doc_msg, "%", arg0, doc_ver,time, 4);
			printf("\n\n%s\n", s, 1);
		}
		if ((l_stat == 0) and (ll_stat == 1))
			printf("%%\n%% from: @%s@\n",file,1);
	}
	() = fclose(fd);
	return(0);
}

% main

variable arg, doc_func, nargs;

% get options first, if none given use tty output
%
doc_fmt = &sldoc_ascii;
doc_func = &sldoc_pre;
while(arg = getarg(), strcmp(arg, "--")) {
	if(arg[0] != '-')
		break;
	switch(arg[1])
	{ case 'i': doc_func = &sldoc_idx; }	% build index
	{ case 'k': doc_key = sprintf("%%%c:",arg[2],1); }% set_key
	{ case 'K': doc_c_key = sprintf("/*%c:",arg[2],1); }% set_c_key
	{ case 'c': doc_func = &sldoc_cconv; }	% C mode comments
	{ case 'l': doc_func = &sldoc_pre; doc_fmt = &sldoc_latex }
	{ case 'L': doc_func = &sldoc_lconv; }  % LaTex ode extract
	{ case 't': doc_func = &sldoc_pre; doc_fmt = &sldoc_troff; }
% for testing only
%	{ case 'g': doc_func = &sldoc_pre; doc_fmt = &sldoc_generic; }
	{ sldoc_usage(); }
}

% do remaining arguments
%
nargs = 0;
while(strcmp(arg, "--")) {
	nargs++;
	() = doc_func(arg);
	arg = getarg();
}

if(nargs == 0)
	sldoc_usage();

%exit;
